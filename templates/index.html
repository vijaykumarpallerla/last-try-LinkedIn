<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LinkedIn Job Scraper Control Panel</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        body {
            background-color: #f0f2f5;
        }
        .container {
            max-width: 700px;
            margin-top: 50px;
        }
        .card {
            border: none;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }
        .card-header {
            background-color: #007bff;
            color: white;
            font-weight: bold;
        }
        .form-text {
            font-size: 0.875em;
        }
        .status-box {
            margin-top: 20px;
            padding: 15px;
            border-radius: 5px;
            background-color: #e9ecef;
            font-family: monospace;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="card">
            <h5 class="card-header text-center">LinkedIn Job Scraper</h5>
            <div class="card-body">
                        <div class="alert alert-info">
                            <strong>Important:</strong> This tool runs on your computer. Keep the terminal window (the black box where you started the app) open while it's running.
                        </div>
                        {% if started %}
                        <div class="alert alert-success" role="alert">
                            Scraper started — keep this page open to see live progress below. Check the terminal for detailed logs.
                        </div>
                        {% endif %}
                <form action="/" method="POST" id="mainForm">
                    <!-- Sender (hidden): read from .env -> GMAIL_USER / GMAIL_PASS -->
                    <h6 class="text-primary">Recipients</h6>
                    <div class="mb-3">
                        <label for="recipient_emails" class="form-label">Recipient Email(s)</label>
                        <input type="text" class="form-control" id="recipient_emails" name="recipient_emails" placeholder="user1@example.com, user2@example.com" value="{{ settings.get('recipients') or env.RECIPIENTS or '' }}">
                        <div class="form-text">Enter one or more emails, separated by commas. These will be saved for next time.</div>
                    </div>

                    <div class="mb-3">
                        <label class="form-label">Extracted mails</label>
                        <div class="d-flex align-items-center">
                            <div id="extractedCount" class="me-3">Count: 0</div>
                            <button id="viewExtractedBtn" type="button" class="btn btn-sm btn-outline-primary me-2">View</button>
                            <button id="clearExtractedBtn" type="button" class="btn btn-sm btn-outline-danger">Clear</button>
                        </div>
                        <div class="form-text">Shows how many unique emails were extracted by the last hold-mode run (or current run). Use View to list them (admin).</div>
                    </div>

                    <hr class="my-4">

                    <h6 class="text-primary">LinkedIn Settings (saved)</h6>
                    <div class="mb-3">
                        <label for="linkedin_user" class="form-label">LinkedIn Email</label>
                        <input type="email" class="form-control" id="linkedin_user" name="linkedin_user" value="{{ settings.get('linkedin_user') or env.LINKEDIN_USER or ''}}">
                    </div>
                    <div class="mb-3">
                        <label for="linkedin_pass" class="form-label">LinkedIn Password</label>
                        <input type="password" class="form-control" id="linkedin_pass" name="linkedin_pass" value="{{ settings.get('linkedin_pass') or ''}}">
                    </div>

                    <h6 class="text-primary">Target Groups</h6>
                        <div class="mb-3">
                            <label for="keywords" class="form-label">Keywords (comma-separated, optional)</label>
                            <input type="text" class="form-control" id="keywords" name="keywords" placeholder="e.g. Python, Django, remote" value="{{ settings.get('keywords') or '' }}">
                            <div class="form-text">If provided, posts containing any of these keywords will be given priority. You can also enable "Require keywords" to only send matching posts.</div>
                        </div>
                        <div class="mb-3 form-check">
                            <input type="checkbox" class="form-check-input" id="use_keywords_search" name="use_keywords_search" {% if settings.get('use_keywords_search') %}checked{% endif %}>
                            <label class="form-check-label" for="use_keywords_search">Search LinkedIn for these keywords (Posts tab)</label>
                            <div class="form-text">When enabled, the scraper will open LinkedIn search for each keyword in the Posts results.</div>
                        </div>
                        
                        <div class="mb-3 form-check">
                            <input type="checkbox" class="form-check-input" id="ai_filter_enabled" name="ai_filter_enabled" {% if settings.get('ai_filter_enabled', true) %}checked{% endif %}>
                            <label class="form-check-label" for="ai_filter_enabled">Use AI to keep only USA hiring posts</label>
                            <div class="form-text">AI will detect if a post is a hiring announcement and limited to the USA. Non-USA or not-hiring posts are skipped.</div>
                        </div>
                        <div class="mb-3 form-check">
                            <input type="checkbox" class="form-check-input" id="include_raw_post" name="include_raw_post" {% if settings.get('include_raw_post', false) %}checked{% endif %}>
                            <label class="form-check-label" for="include_raw_post">Include raw post below cleaned text</label>
                            <div class="form-text">Turn this off to avoid emails that look duplicated. When on, the app only adds the raw post if it’s sufficiently different.</div>
                        </div>
                        <div class="mb-3 form-check">
                            <input type="checkbox" class="form-check-input" id="hold_emails_only" name="hold_emails_only">
                            <label class="form-check-label" for="hold_emails_only">Hold mode: only collect emails (do not send)</label>
                            <div class="form-text">When enabled, the scraper will extract contact emails and save them to <code>extracted-emails.json</code> instead of sending emails.</div>
                        </div>
                        <div class="mb-3 form-check">
                            <input type="checkbox" class="form-check-input" id="require_keywords" name="require_keywords" {% if settings.get('require_keywords') %}checked{% endif %}>
                            <label class="form-check-label" for="require_keywords">Require keywords (only send posts that match)</label>
                        </div>
                    <div id="groupsList" class="mb-3">
                        <!-- Groups will be populated by JS -->
                    </div>
                    <div class="input-group mb-3">
                        <input type="text" id="groupUrl" class="form-control" placeholder="https://www.linkedin.com/groups/12345/">
                        <input type="text" id="groupName" class="form-control" placeholder="Optional group name">
                        <button class="btn btn-outline-secondary" type="button" id="addGroupBtn">Add Group</button>
                    </div>

                <div class="d-grid gap-2">
                    <button type="submit" id="submitBtn" class="btn btn-primary btn-lg">Start Scraping</button>
                    <button type="button" id="stopBtn" class="btn btn-outline-danger btn-lg">Stop Scraping</button>
                </div>
                </form>
                <div class="mt-3">
                    <form id="optionsForm">
                        <div class="row g-2">
                            <div class="col-auto">
                                <label for="delay_seconds" class="form-label">Delay (seconds)</label>
                                <input type="number" class="form-control" id="delay_seconds" name="delay_seconds" value="10" min="0">
                            </div>
                            <div class="col-auto align-self-end">
                                <div class="form-check mt-2">
                                    <input class="form-check-input" type="checkbox" id="send_separately" name="send_separately" checked>
                                    <label class="form-check-label" for="send_separately">Send each post as a separate email</label>
                                </div>
                            </div>
                        </div>
                        <div class="form-text mt-2">The delay and checkbox are included when you press <strong>Start Scraping</strong>.</div>
                    </form>
                </div>
                
                <div id="statusBox" class="status-box">
                    <div id="statusMain">Status: Idle. Ready to start.</div>
                    <div id="groupsSummary" style="margin-top:8px; font-size:0.9em;"></div>
                    <div id="lastSummary" style="margin-top:8px; font-size:0.9em;"></div>
                        <div id="aiSummary" style="margin-top:8px; font-size:0.9em;"></div>
                </div>
                <div class="mt-3">
                    <button id="backupBtn" class="btn btn-sm btn-secondary">Backup DB</button>
                    <span id="backupMsg" style="margin-left:8px;"></span>
                    <div class="mt-3">
                        <h6 class="text-primary">Database maintenance</h6>
                        <div class="mb-2">Sent jobs in DB: <span id="sentJobsCount">...</span> <button id="refreshSentBtn" class="btn btn-sm btn-link">Refresh</button></div>
                        <div class="mb-2">
                            <button id="downloadLatestBackupBtn" class="btn btn-sm btn-outline-secondary">Download latest backup</button>
                            <span id="latestBackupLink" style="margin-left:8px"></span>
                        </div>
                        <div class="mb-2">
                            <button id="deleteAllBtn" class="btn btn-danger btn-sm">Delete all sent jobs</button>
                            <span class="text-muted" style="margin-left:8px;">(Use with caution)</span>
                        </div>
                        <div class="mb-2 input-group" style="max-width:320px;">
                            <input type="number" id="deleteDays" class="form-control" placeholder="Days (e.g. 30)" value="30" min="1">
                            <button id="deleteOlderBtn" class="btn btn-warning btn-sm">Delete older than days</button>
                        </div>
                        <div class="mb-2 input-group" style="max-width:420px;">
                            <input type="email" id="deleteEmail" class="form-control" placeholder="Delete jobs sent to email@example.com">
                            <button id="deleteByEmailBtn" class="btn btn-outline-danger btn-sm">Delete by email</button>
                        </div>
                        <div id="dbMsg" style="margin-top:8px;"></div>
                        <!-- Admin senders management (requires ADMIN_TOKEN) -->
                        <div id="adminSendersSection" style="margin-top:16px; display:none;">
                            <h6 class="text-primary">Sender Accounts (admin)</h6>
                            <div id="sendersList" style="margin-bottom:8px;">Loading...</div>
                            <div class="input-group mb-2" style="max-width:720px;">
                                <input type="email" id="senderUser" class="form-control" placeholder="sender@example.com">
                                <input type="password" id="senderPass" class="form-control" placeholder="password / app password">
                                <input type="text" id="senderHost" class="form-control" placeholder="smtp host (optional)">
                                <input type="number" id="senderPort" class="form-control" placeholder="port (optional)">
                                <button id="addSenderBtn" class="btn btn-success">Add Sender</button>
                            </div>
                            <div class="form-text">Add multiple sender accounts to distribute sending. Use company SMTP credentials and app-specific passwords if possible.</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // admin token injected by server if configured
        const ADMIN_TOKEN = '{{ admin_token or "" }}';

        function adminFetch(url, opts) {
            opts = opts || {};
            opts.headers = opts.headers || {};
            if (ADMIN_TOKEN) {
                opts.headers['X-Admin-Token'] = ADMIN_TOKEN;
            }
            return fetch(url, opts);
        }

        // This script will periodically check the status from the Flask backend
        const statusBox = document.getElementById('statusBox');
    const submitBtn = document.getElementById('submitBtn');
    const stopBtn = document.getElementById('stopBtn');

        function checkStatus() {
            fetch('/status')
                .then(response => response.json())
                .then(data => {
                    document.getElementById('statusMain').textContent = 'Status: ' + data.progress;
                    // render per-group summaries (name: count)
                    const gsDiv = document.getElementById('groupsSummary');
                    const lsDiv = document.getElementById('lastSummary');
                    if (data.groups_summary && data.groups_summary.length) {
                        const lines = data.groups_summary.map(g => `${g.name}: ${g.recent_count} recent`);
                        gsDiv.textContent = lines.join(' | ');
                    } else {
                        gsDiv.textContent = '';
                    }
                    // show total found and last sent summary
                    const totalFound = data.last_found_total || 0;
                    const lastSent = data.last_sent_count || 0;
                    const lastTo = data.last_sent_to || '';
                    lsDiv.textContent = `Found ${totalFound} recent posts total. Last sent: ${lastSent} to ${lastTo}`;
                    const aiDiv = document.getElementById('aiSummary');
                    if (data.ai_filter_stats) {
                        aiDiv.textContent = `AI filter — kept: ${data.ai_filter_stats.kept || 0}, skipped: ${data.ai_filter_stats.skipped || 0}`;
                    } else {
                        aiDiv.textContent = '';
                    }

                    // Update extracted emails count if present in status
                    const extractedCount = document.getElementById('extractedCount');
                    if (data.extracted_emails_count !== undefined) {
                        extractedCount.textContent = 'Count: ' + (data.extracted_emails_count || 0);
                    }

                    if (data.paused_for_human_verification) {
                        // Show an explicit paused message so users don't think the scraper is still searching
                        document.getElementById('statusMain').textContent = 'Status: Paused - awaiting human verification (OTP)';
                        submitBtn.disabled = true;
                        stopBtn.disabled = false;
                        submitBtn.textContent = 'Scraper Paused';
                        // If the API exposes a short job hint or token, display it (best-effort)
                        try {
                            if (data.paused_token) {
                                const tokenEl = document.getElementById('pausedToken');
                                if (tokenEl) tokenEl.textContent = data.paused_token;
                            }
                        } catch (e) {}
                    } else if (data.is_running) {
                        submitBtn.disabled = true;
                        stopBtn.disabled = false;
                        submitBtn.textContent = 'Scraping in Progress...';
                    } else {
                        submitBtn.disabled = false;
                        stopBtn.disabled = true;
                        submitBtn.textContent = 'Start Scraping';
                    }
                })
                .catch(error => {
                    console.error('Error fetching status:', error);
                    statusBox.textContent = 'Status: Could not connect to the server.';
                });
        }

        // Check the status every 3 seconds
        setInterval(checkStatus, 3000);
        // Also check right away when the page loads
        document.addEventListener('DOMContentLoaded', checkStatus);

        // --- Groups management ---
        async function loadGroups() {
                const res = await fetch('/groups');
            const data = await res.json();
            const list = document.getElementById('groupsList');
            list.innerHTML = '';
            data.groups.forEach((g, i) => {
                const row = document.createElement('div');
                row.className = 'input-group mb-2';
                row.innerHTML = `<input class="form-control" value="${g.url}" readonly><input class="form-control" value="${g.name}" readonly><button type="button" class="btn btn-danger" data-index="${i}" data-url="${g.url}">Remove</button>`;
                list.appendChild(row);
            });
            // attach remove handlers
            document.querySelectorAll('#groupsList .btn-danger').forEach(btn => {
                btn.addEventListener('click', async (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    const url = e.target.getAttribute('data-url');
                    if (!url) return;
                    await fetch(`/groups?url=${encodeURIComponent(url)}`, { method: 'DELETE' });
                    loadGroups();
                });
            });
        }

        document.getElementById('addGroupBtn').addEventListener('click', async () => {
            const url = document.getElementById('groupUrl').value.trim();
            const name = document.getElementById('groupName').value.trim();
            if (!url) return alert('Group URL required');
            await fetch('/groups', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ url, name }) });
            document.getElementById('groupUrl').value = '';
            document.getElementById('groupName').value = '';
            loadGroups();
        });

        // On page load populate groups and prefill recipients/linkedin
        document.addEventListener('DOMContentLoaded', () => {
            loadGroups();
            // prefill recipients and linkedin fields if provided by the template
            const recipients = '{{ settings.get("recipients") or env.RECIPIENTS or "" }}';
            if (recipients) document.getElementById('recipient_emails').value = recipients;
            const ln = '{{ settings.get("linkedin_user") or env.LINKEDIN_USER or "" }}';
            if (ln) document.getElementById('linkedin_user').value = ln;
        });

        // Stop button handler (attach once)
        stopBtn.addEventListener('click', async () => {
            try {
                stopBtn.disabled = true;
                const res = await fetch('/stop', { method: 'POST' });
                if (!res.ok) {
                    const t = await res.text();
                    alert('Stop failed: ' + t);
                }
            } catch (e) {
                console.error('Failed to stop', e);
                alert('Failed to send stop request');
            } finally {
                // Trigger a status refresh soon
                setTimeout(checkStatus, 500);
            }
        });

        // When main form submits, include delay and checkbox values by copying them into the form
        document.getElementById('mainForm').addEventListener('submit', (e) => {
            const delayInput = document.getElementById('delay_seconds');
            const sendCheck = document.getElementById('send_separately');
            // ensure those elements are inside the main form so they're posted
            if (!delayInput.name) delayInput.name = 'delay_seconds';
            if (!sendCheck.name) sendCheck.name = 'send_separately';
            const aiCheck = document.getElementById('ai_filter_enabled');
            if (!aiCheck.name) aiCheck.name = 'ai_filter_enabled';
            const rawCheck = document.getElementById('include_raw_post');
            if (rawCheck && !rawCheck.name) rawCheck.name = 'include_raw_post';
        });

        // Backup button handler
        document.getElementById('backupBtn').addEventListener('click', async () => {
            const btn = document.getElementById('backupBtn');
            const msg = document.getElementById('backupMsg');
            btn.disabled = true;
            msg.textContent = 'Backing up...';
            try {
                const res = await adminFetch('/admin/backup', { method: 'POST' });
                const data = await res.json();
                if (data.ok) {
                    msg.textContent = 'Backup created: ' + data.backup;
                } else {
                    msg.textContent = 'Backup failed: ' + (data.error || 'unknown');
                }
            } catch (e) {
                msg.textContent = 'Backup request failed';
            } finally {
                btn.disabled = false;
            }
        });

        // DB maintenance handlers
        async function fetchSentCount() {
            try {
                const res = await adminFetch('/admin/sent-jobs');
                const data = await res.json();
                if (data.ok) {
                    document.getElementById('sentJobsCount').textContent = data.count;
                } else {
                    document.getElementById('sentJobsCount').textContent = 'error';
                }
            } catch (e) {
                document.getElementById('sentJobsCount').textContent = 'error';
            }
        }

        document.getElementById('refreshSentBtn').addEventListener('click', fetchSentCount);

        document.getElementById('deleteAllBtn').addEventListener('click', async () => {
            if (!confirm('Delete ALL sent jobs from the database? This cannot be undone.')) return;
            const msg = document.getElementById('dbMsg');
            msg.textContent = 'Deleting...';
            try {
                const res = await adminFetch('/admin/sent-jobs/clear', { method: 'POST' });
                const data = await res.json();
                if (data.ok) {
                    msg.textContent = 'All sent jobs deleted.' + (data.backup ? ' Backup: ' + data.backup : '');
                    fetchSentCount();
                } else {
                    msg.textContent = 'Delete failed: ' + (data.error || 'unknown');
                }
            } catch (e) {
                msg.textContent = 'Delete request failed';
            }
        });

        document.getElementById('deleteOlderBtn').addEventListener('click', async () => {
            const days = parseInt(document.getElementById('deleteDays').value || '30', 10);
            if (!days || days < 1) return alert('Enter a valid number of days');
            if (!confirm(`Delete sent jobs older than ${days} days?`)) return;
            const msg = document.getElementById('dbMsg');
            msg.textContent = 'Deleting...';
            try {
                const res = await adminFetch('/admin/sent-jobs/delete-old', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ days }) });
                const data = await res.json();
                if (data.ok) {
                    msg.textContent = `Deleted ${data.deleted} sent jobs older than ${days} days.` + (data.backup ? ' Backup: ' + data.backup : '');
                    fetchSentCount();
                } else {
                    msg.textContent = 'Delete failed: ' + (data.error || 'unknown');
                }
            } catch (e) {
                msg.textContent = 'Delete request failed';
            }
        });

        document.getElementById('deleteByEmailBtn').addEventListener('click', async () => {
            const email = (document.getElementById('deleteEmail').value || '').trim();
            if (!email) return alert('Enter an email to delete');
            if (!confirm(`Delete sent jobs sent to ${email}?`)) return;
            const msg = document.getElementById('dbMsg');
            msg.textContent = 'Deleting...';
            try {
                const res = await adminFetch('/admin/sent-jobs/delete-by-email', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ email }) });
                const data = await res.json();
                if (data.ok) {
                    msg.textContent = `Deleted ${data.deleted} sent jobs for ${email}.` + (data.backup ? ' Backup: ' + data.backup : '');
                    fetchSentCount();
                } else {
                    msg.textContent = 'Delete failed: ' + (data.error || 'unknown');
                }
            } catch (e) {
                msg.textContent = 'Delete request failed';
            }
        });

        // initial fetch
        fetchSentCount();

        document.getElementById('downloadLatestBackupBtn').addEventListener('click', async () => {
            const linkSpan = document.getElementById('latestBackupLink');
            linkSpan.textContent = 'Loading...';
            try {
                const res = await adminFetch('/admin/backups/latest');
                const data = await res.json();
                if (data.ok && data.download) {
                    // show a direct link
                    linkSpan.innerHTML = `<a href="${data.download}" target="_blank">Download: ${data.latest}</a>`;
                } else {
                    linkSpan.textContent = 'No backups found';
                }
            } catch (e) {
                linkSpan.textContent = 'Failed to fetch backups';
            }
        });

        // --- Admin senders management ---
        async function loadSenders() {
            if (!ADMIN_TOKEN) return;
            try {
                document.getElementById('adminSendersSection').style.display = 'block';
                const res = await adminFetch('/admin/senders');
                const data = await res.json();
                const list = document.getElementById('sendersList');
                if (!data.ok) {
                    list.textContent = 'Failed to load senders';
                    return;
                }
                if (!data.senders || !data.senders.length) {
                    list.innerHTML = '<div class="text-muted">No senders configured.</div>';
                    return;
                }
                list.innerHTML = '';
                data.senders.forEach((s, i) => {
                    const row = document.createElement('div');
                    row.className = 'd-flex align-items-center mb-1';
                    row.innerHTML = `<div style="flex:1">${s.user} (${s.host || 'smtp'})</div><button class="btn btn-sm btn-danger ms-2" data-index="${i}">Delete</button>`;
                    list.appendChild(row);
                });
                // attach delete handlers
                list.querySelectorAll('button[data-index]').forEach(btn => {
                    btn.addEventListener('click', async (e) => {
                        const idx = parseInt(e.target.getAttribute('data-index'));
                        if (!confirm('Delete this sender?')) return;
                        const res = await adminFetch('/admin/senders', { method: 'DELETE', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ index: idx }) });
                        const d = await res.json();
                        if (d.ok) loadSenders(); else alert('Delete failed');
                    });
                });
            } catch (e) {
                console.error('Failed to load senders', e);
            }
        }

        document.getElementById('addSenderBtn').addEventListener('click', async () => {
            const user = document.getElementById('senderUser').value.trim();
            const pass = document.getElementById('senderPass').value.trim();
            const host = document.getElementById('senderHost').value.trim() || undefined;
            const port = parseInt(document.getElementById('senderPort').value) || undefined;
            if (!user || !pass) return alert('user and pass required');
            try {
                const res = await adminFetch('/admin/senders', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ user, pass, host, port }) });
                const d = await res.json();
                if (d.ok) {
                    document.getElementById('senderUser').value = '';
                    document.getElementById('senderPass').value = '';
                    document.getElementById('senderHost').value = '';
                    document.getElementById('senderPort').value = '';
                    loadSenders();
                } else {
                    alert('Add sender failed: ' + (d.error || 'unknown'));
                }
            } catch (e) {
                console.error('Add sender failed', e);
                alert('Add sender failed');
            }
        });

        // load senders on page load if admin token is present
        if (ADMIN_TOKEN) {
            document.addEventListener('DOMContentLoaded', loadSenders);
        }

        // View / Clear extracted emails (admin)
        document.getElementById('viewExtractedBtn').addEventListener('click', async () => {
            try {
                const res = await adminFetch('/admin/extracted-emails');
                const data = await res.json();
                if (!data.ok) return alert('Failed to load extracted emails: ' + (data.error || 'unknown'));
                if (!data.count) return alert('No extracted emails found');
                // build a simple list
                const lines = data.emails.map(e => `${e.email} — ${e.group_name || ''} — ${e.snippet ? e.snippet.slice(0,80) : ''}`);
                alert('Extracted emails:\n\n' + lines.join('\n'));
            } catch (e) {
                console.error('Failed to fetch extracted emails', e);
                alert('Failed to fetch extracted emails');
            }
        });

        document.getElementById('clearExtractedBtn').addEventListener('click', async () => {
            if (!confirm('Clear extracted emails file? This will remove the current list.')) return;
            try {
                const res = await adminFetch('/admin/extracted-emails/clear', { method: 'POST' });
                const data = await res.json();
                if (data.ok) {
                    document.getElementById('extractedCount').textContent = 'Count: 0';
                    alert('Cleared extracted emails file');
                } else {
                    alert('Failed to clear: ' + (data.error || 'unknown'));
                }
            } catch (e) {
                console.error('Failed to clear extracted emails', e);
                alert('Failed to clear extracted emails');
            }
        });
    </script>
</body>
</html>
```

---

### Step 4: How to Run Everything

**1. Install Python Libraries:**
Open your terminal or command prompt and install the necessary libraries:
```bash
pip install Flask selenium
```

**2. Download ChromeDriver:**
Selenium needs a "driver" to control the Chrome browser.
* Go to the [Chrome for Testing availability](https://googlechromelabs.github.io/chrome-for-testing/) page.
* Find the version of ChromeDriver that matches your version of Google Chrome.
* Download it and place the `chromedriver.exe` (on Windows) or `chromedriver` (on Mac/Linux) file somewhere you can find it.
* **Crucially, update the path in `app.py` on line 42.** If you add the driver to your system's PATH, you can leave `Service()` empty as it is in the code.

**3. Run the Flask App:**
In your terminal, navigate to your `flask_scraper` folder and run this command:
```bash
flask run --port=5001